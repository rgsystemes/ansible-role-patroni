---

- name: Patroni | Install Patroni
  block:
    - name: Patroni | Copy patroni requirements.txt file
      ansible.builtin.copy:
        src: requirements.txt
        dest: /tmp/requirements.txt

    - name: Patroni | Install setuptools
      ansible.builtin.pip:
        name: setuptools<66.0.0
        state: latest
        executable: pip3
        extra_args: "--trusted-host=pypi.python.org --trusted-host=pypi.org --trusted-host=files.pythonhosted.org"
        umask: "0022"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"

    - name: Patroni | Install requirements
      ansible.builtin.pip:
        requirements: /tmp/requirements.txt
        executable: pip3
        extra_args: "--trusted-host=pypi.python.org --trusted-host=pypi.org --trusted-host=files.pythonhosted.org"
        umask: "0022"
      environment:
        PATH: "{{ ansible_env.PATH }}:{{ postgresql_bin_dir }}:/usr/local/bin:/usr/bin"

    - name: "Patroni | Install patroni {{ patroni_install_version }}"
      ansible.builtin.pip:
        name: "patroni=={{ patroni_install_version }}"
        executable: pip3
        extra_args: "--trusted-host=pypi.python.org --trusted-host=pypi.org --trusted-host=files.pythonhosted.org"
        umask: "0022"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      when: patroni_install_version != "latest"
  vars:
    ansible_python_interpreter: /usr/bin/python3
  tags: ['patroni']

- name: Patroni | Create conf directory
  ansible.builtin.file:
    path: "{{ patroni_conf_dir }}"
    state: directory
    owner: postgres
    group: postgres
    mode: 0750
  tags: ['patroni']

- name: Patroni | Generate conf file "{{ patroni_conf_dir }}/patroni.yml"
  ansible.builtin.template:
    src: patroni.yml.j2
    dest: "{{ patroni_conf_dir }}/patroni.yml"
    owner: postgres
    group: postgres
    mode: 0640
  when: existing_pgcluster is not defined or not existing_pgcluster|bool
  tags: ['patroni']

- name: Patroni | Create patroni log directory
  ansible.builtin.file:
    path: "{{ patroni_log_dir }}"
    owner: postgres
    group: postgres
    state: directory
    mode: 0750
  when: patroni_log_destination == 'logfile'
  tags: ['patroni']

- name: Patroni | Add only one Patroni node | add_pgnode.yml
  block:
    - name: Patroni | Fetch patroni.yml conf file from master
      run_once: true
      ansible.builtin.fetch:
        src: /etc/patroni/patroni.yml
        dest: files/patroni.yml
        validate_checksum: true
        flat: true
      when: is_master is defined and is_master|bool

    - name: Patroni | Copy patroni.yml conf file to replica
      ansible.builtin.copy:
        src: files/patroni.yml
        dest: /etc/patroni/patroni.yml
        owner: postgres
        group: postgres
        mode: 0640

    - name: Patroni | Remove patroni.yml conf files from localhost
      run_once: true
      ansible.builtin.file:
        path: files/patroni.yml
        state: absent
      delegate_to: localhost

    - name: Patroni | Prepare patroni.yml conf file (replace "name","listen","connect_address")
      ansible.builtin.lineinfile:
        path: /etc/patroni/patroni.yml
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        backrefs: true
      loop:
        - { regexp: '^name:', line: 'name: {{ ansible_hostname }}' }
        - { regexp: '^  listen: .*:{{ patroni_restapi_port }}$', line: '  listen: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ patroni_restapi_port }}' }
        - { regexp: '^  connect_address: .*:{{ patroni_restapi_port }}$', line: '  connect_address: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ patroni_restapi_port }}' }
        - { regexp: '^  listen: ((?!{{ patroni_restapi_port }}).)*$', line: '  listen: {{ hostvars[inventory_hostname].inventory_hostname }},127.0.0.1:{{ postgresql_port }}' }
        - { regexp: '^  connect_address: ((?!{{ patroni_restapi_port }}).)*$', line: '  connect_address: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ postgresql_port }}' }
      loop_control:
        label: "{{ item.line }}"
      when: with_haproxy_load_balancing|bool or pgbouncer_install|bool or (cluster_vip is not defined or cluster_vip | length < 1)

    - name: Patroni | Prepare patroni.yml conf file (replace "name","listen","connect_address")
      ansible.builtin.lineinfile:
        path: /etc/patroni/patroni.yml
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        backrefs: true
      loop:
        - { regexp: '^name:', line: 'name: {{ ansible_hostname }}' }
        - { regexp: '^  listen: .*:{{ patroni_restapi_port }}$', line: '  listen: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ patroni_restapi_port }}' }
        - { regexp: '^  connect_address: .*:{{ patroni_restapi_port }}$', line: '  connect_address: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ patroni_restapi_port }}' }
        - { regexp: '^  listen: ((?!{{ patroni_restapi_port }}).)*$', line: '  listen: {{ hostvars[inventory_hostname].inventory_hostname }},{{ cluster_vip }},127.0.0.1:{{ postgresql_port }}' }
        - { regexp: '^  connect_address: ((?!{{ patroni_restapi_port }}).)*$', line: '  connect_address: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ postgresql_port }}' }
      loop_control:
        label: "{{ item.line }}"
      when: not with_haproxy_load_balancing|bool and not pgbouncer_install|bool and (cluster_vip is defined and cluster_vip | length > 0)
  when: existing_pgcluster is defined and existing_pgcluster|bool
  tags: ['patroni']

- name: Patroni | Copy systemd service file "/etc/systemd/system/patroni.service"
  ansible.builtin.template:
    src: patroni.service.j2
    dest: /etc/systemd/system/patroni.service
    owner: postgres
    group: postgres
    mode: 0644
  tags: ['patroni']

- name: Prepare PostgreSQL | create statistics directory (if not already exists)
  ansible.builtin.file:
    path: "{{ postgresql_stats_temp_directory_path }}"
    state: directory
    mode: 01777
  when:
    - postgresql_stats_temp_directory_path is defined
    - postgresql_stats_temp_directory_path != 'none'
    - postgresql_version is version('14', '<=')
  tags: ['patroni']

- name: Prepare PostgreSQL | mount the statistics directory in memory (tmpfs)
  ansible.builtin.mount:
    path: "{{ postgresql_stats_temp_directory_path }}"
    src: tmpfs
    fstype: tmpfs
    opts: "size={{ postgresql_stats_temp_directory_size }},uid=postgres,gid=postgres"
    state: mounted
  when:
    - postgresql_stats_temp_directory_path is defined
    - postgresql_stats_temp_directory_path != 'none'
    - postgresql_version is version('14', '<=')
  tags: ['patroni']

- name: Prepare PostgreSQL | make sure the custom WAL directory "{{ postgresql_wal_dir }}" exists
  ansible.builtin.file:
    path: "{{ postgresql_wal_dir }}"
    owner: postgres
    group: postgres
    state: directory
    mode: 0700
  when: postgresql_wal_dir is defined and postgresql_wal_dir | length > 0
  tags: ['patroni']

- name: Prepare PostgreSQL | When PostgreSQL does not exist
  block:
    - name: Prepare PostgreSQL | check that data directory "{{ postgresql_data_dir }}" is not initialized
      stat:
        path: "{{ postgresql_data_dir }}/PG_VERSION"
      register: pgdata_initialized
      when: patroni_cluster_bootstrap_method == "initdb"

    - name: Prepare PostgreSQL | data directory check result
      fail:
        msg: "Whoops! data directory {{ postgresql_data_dir }} is already initialized"
      when: pgdata_initialized.stat.exists is defined and
            pgdata_initialized.stat.exists
      tags: patroni, patroni_check_init

    - name: Prepare PostgreSQL | make sure the postgresql config files exists
      stat:
        path: "{{ postgresql_conf_dir }}/postgresql.conf"
      register: postgresql_conf_file

    - name: Prepare PostgreSQL | generate default postgresql config files
      become: true
      become_user: postgres
      command: >
        /usr/bin/pg_createcluster {{ postgresql_version }} {{ postgresql_cluster_name }}
        -d {{ postgresql_data_dir }}
        -p {{ postgresql_port }}
        -e {{ postgresql_encoding }}
        --locale {{ postgresql_locale }}
      register: pg_createcluster_result
      failed_when: pg_createcluster_result.rc != 0
      when: not postgresql_conf_file.stat.exists

    - name: Prepare PostgreSQL | make sure the data directory "{{ postgresql_data_dir }}" is empty
      file:
        path: "{{ postgresql_data_dir }}"
        state: "{{ item }}"
        owner: postgres
        group: postgres
        mode: 0700
      loop:
        - absent
        - directory
      when: is_master is defined and is_master|bool

    - name: Prepare PostgreSQL | make sure the custom WAL directory "{{ postgresql_wal_dir }}" is empty
      file:
        path: "{{ postgresql_wal_dir }}"
        state: "{{ item }}"
        owner: postgres
        group: postgres
        mode: 0700
      loop:
        - absent
        - directory
      when: (postgresql_wal_dir is defined and postgresql_wal_dir | length > 0) and
            (is_master is defined and is_master|bool)
  when: postgresql_exists != "true" or patroni_cluster_bootstrap_method != "initdb"
  tags: ['patroni']

- name: Prepare PostgreSQL | When PostgreSQL does exist
  block:
    - name: Prepare PostgreSQL | check that data directory "{{ postgresql_data_dir }}" is initialized
      ansible.builtin.stat:
        path: "{{ postgresql_data_dir }}/PG_VERSION"
      register: pgdata_initialized

    - name: Prepare PostgreSQL | data directory check result
      ansible.builtin.fail:
        msg: "Whoops! data directory {{ postgresql_data_dir }} is not initialized"
      when: not pgdata_initialized.stat.exists

    - name: Prepare PostgreSQL | Check PostgreSQL on master
      block:
        - name: Prepare PostgreSQL | check PostgreSQL is started on Master
          become: true
          become_user: postgres
          ansible.builtin.command: "{{ postgresql_bin_dir }}/pg_ctl status -D {{ postgresql_data_dir }}"
          register: pg_ctl_status_result
          changed_when: false
          failed_when:
            - pg_ctl_status_result.rc != 0
            - pg_ctl_status_result.rc != 3

        - name: Prepare PostgreSQL | start PostgreSQL on Master
          become: true
          become_user: postgres
          ansible.builtin.command: "/usr/bin/pg_ctlcluster {{ postgresql_version }} {{ postgresql_cluster_name }} start"
          register: pg_start_on_master
          when: pg_ctl_status_result.rc == 3 and
                postgresql_packages|join(" ") is not search("postgrespro")

        - name: Prepare PostgreSQL | check PostgreSQL is accepting connections
          become: true
          become_user: postgres
          ansible.builtin.command: "{{ postgresql_bin_dir }}/pg_isready -p {{ postgresql_port }}"
          register: pg_isready_result
          until: pg_isready_result.rc == 0
          retries: 30
          delay: 10
          changed_when: false

        - name: Prepare PostgreSQL | generate pg_hba.conf on Master
          ansible.builtin.template:
            src: templates/pg_hba.conf.j2
            dest: "{{ postgresql_conf_dir }}/pg_hba.conf"
            owner: postgres
            group: postgres
            mode: 0640

        - name: Prepare PostgreSQL | reload for apply the pg_hba.conf
          become: true
          become_user: postgres
          ansible.builtin.command: "{{ postgresql_bin_dir }}/psql -p {{ postgresql_port }} -c 'SELECT pg_reload_conf()'"
          register: psql_reload_result
          failed_when: psql_reload_result.rc != 0

        - name: Prepare PostgreSQL | make sure the user "{{ patroni_superuser_username }}" are present, and password does not differ from the specified
          ansible.builtin.postgresql_user:
            db: postgres
            name: "{{ patroni_superuser_username }}"
            password: "{{ patroni_superuser_password }}"
            encrypted: true
            role_attr_flags: "SUPERUSER"
            login_unix_socket: "{{ postgresql_unix_socket_dir }}"
            port: "{{ postgresql_port }}"
            state: present
          become: true
          become_user: postgres

        - name: Prepare PostgreSQL | make sure the user "{{ patroni_replication_username }}" are present, and password does not differ from the specified
          ansible.builtin.postgresql_user:
            db: postgres
            name: "{{ patroni_replication_username }}"
            password: "{{ patroni_replication_password }}"
            encrypted: true
            role_attr_flags: "LOGIN,REPLICATION"
            login_unix_socket: "{{ postgresql_unix_socket_dir }}"
            port: "{{ postgresql_port }}"
            state: present
          become: true
          become_user: postgres
      when: is_master is defined and is_master|bool

    - name: Prepare PostgreSQL | check PostgreSQL is started
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ postgresql_bin_dir }}/pg_ctl status -D {{ postgresql_data_dir }}"
      register: pg_ctl_status_result
      changed_when: false
      failed_when:
        - pg_ctl_status_result.rc != 0
        - pg_ctl_status_result.rc != 3

    - name: Prepare PostgreSQL | waiting for CHECKPOINT to complete before stopping postgresql
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ postgresql_bin_dir }}/psql -p {{ postgresql_port }} -c 'CHECKPOINT'"
      register: checkpoint_result
      until: checkpoint_result.rc == 0
      retries: 300
      delay: 10
      when: pg_ctl_status_result.rc == 0

    - name: Prepare PostgreSQL | stop PostgreSQL (will be managed by patroni)
      become: true
      become_user: postgres
      ansible.builtin.command: "/usr/bin/pg_ctlcluster {{ postgresql_version }} {{ postgresql_cluster_name }} stop -m fast -- -w -t 600"
      when: (checkpoint_result.rc is defined and checkpoint_result.rc == 0) and
            postgresql_packages|join(" ") is not search("postgrespro")

    - name: Prepare PostgreSQL | check PostgreSQL is stopped
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ postgresql_bin_dir }}/pg_ctl status -D {{ postgresql_data_dir }}"
      register: pg_ctl_stop_result
      failed_when: pg_ctl_stop_result.rc != 3
      changed_when: false
  when: postgresql_exists == "true" and patroni_cluster_bootstrap_method == "initdb"
  tags: ['patroni']

- name: Patroni | Start Patroni on master
  block:
    - name: Patroni | Start patroni service on the Master server
      ansible.builtin.systemd:
        daemon_reload: true
        name: patroni
        state: restarted
        enabled: true

    - name: "Patroni | Wait for port {{ patroni_restapi_port }} to become open on the host"
      ansible.builtin.wait_for:
        port: "{{ patroni_restapi_port }}"
        host: "{{ hostvars[inventory_hostname]['inventory_hostname'] }}"
        state: started
        timeout: 120
        delay: 10
      ignore_errors: false

    - name: Patroni | Check PostgreSQL is started and accepting connections on Master
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ postgresql_bin_dir }}/pg_isready -p {{ postgresql_port }}"
      register: pg_isready_result
      until: pg_isready_result.rc == 0
      retries: 1000
      delay: 30
      changed_when: false

    - name: Patroni | Wait for the cluster to initialize (master is the leader with the lock)
      ansible.builtin.uri:
        url: "http://{{ hostvars[inventory_hostname]['inventory_hostname'] }}:{{ patroni_restapi_port }}/leader"
        status_code: 200
      register: result
      until: result.status == 200
      retries: 10
      delay: 2
      when: patroni_standby_cluster.host is not defined or patroni_standby_cluster.host | length < 1
  when: is_master is defined and is_master|bool
  tags: ['patroni']

- name: Prepare PostgreSQL | Generate pg_hba.conf when PostgreSQL does not exist
  block:
    - name: Prepare PostgreSQL | Generate pg_hba.conf
      ansible.builtin.template:
        src: pg_hba.conf.j2
        dest: "{{ postgresql_conf_dir }}/pg_hba.conf"
        owner: postgres
        group: postgres
        mode: 0640
      register: generate_pg_hba
      when: (is_master is defined and is_master|bool) or
            ((is_master is undefined and postgresql_conf_dir != postgresql_data_dir)
            or postgresql_exists == "true")

    - name: Prepare PostgreSQL | reload for apply the pg_hba.conf
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ postgresql_bin_dir }}/psql -p {{ postgresql_port }} -c 'SELECT pg_reload_conf()'"
      register: psql_reload_result
      changed_when: psql_reload_result.rc == 0
      failed_when: false  # exec pg_reload_conf on all running postgres (to re-run with --tag pg_hba).
      when: generate_pg_hba is changed
  when: existing_pgcluster is not defined or not existing_pgcluster|bool
  tags: ['patroni']

- name: Prepare PostgreSQL | Add only one Patroni node | add_pgnode.yml
  block:
    - name: Prepare PostgreSQL | fetch pg_hba.conf file from master
      run_once: true
      ansible.builtin.fetch:
        src: "{{ postgresql_conf_dir }}/pg_hba.conf"
        dest: files/pg_hba.conf
        validate_checksum: true
        flat: true
      when: is_master is defined and is_master|bool

    - name: Prepare PostgreSQL | copy pg_hba.conf file to replica
      ansible.builtin.copy:
        src: files/pg_hba.conf
        dest: "{{ postgresql_conf_dir }}/pg_hba.conf"
        owner: postgres
        group: postgres
        mode: 0640
  when: existing_pgcluster is defined and existing_pgcluster|bool
        and postgresql_conf_dir != postgresql_data_dir
  tags: ['patroni']

- name: Patroni | Start Patroni on replicas
  block:
    - name: Patroni | Start patroni service on Replica servers
      ansible.builtin.systemd:
        daemon_reload: true
        name: patroni
        state: restarted
        enabled: true

    - name: Patroni | "Wait for port {{ patroni_restapi_port }} to become open on the host"
      ansible.builtin.wait_for:
        port: "{{ patroni_restapi_port }}"
        host: "{{ hostvars[inventory_hostname]['inventory_hostname'] }}"
        state: started
        timeout: 120
        delay: 10
      ignore_errors: false

    - name: Patroni | Check that the patroni is healthy on the replica server
      ansible.builtin.uri:
        url: "http://{{ hostvars[inventory_hostname]['inventory_hostname'] }}:{{ patroni_restapi_port }}/health"
        status_code: 200
      register: replica_result
      until: replica_result.status == 200
      retries: 1200 
      delay: 30
  when: is_master is not defined or not is_master|bool
  tags: ['patroni']

- name: WAL | Configure a custom WAL
  import_tasks: custom_wal_dir.yml
  when: postgresql_wal_dir is defined and postgresql_wal_dir | length > 0
  tags: ['patroni']

- name: PostgreSQL | Disable postgresql from autostart
  block:
    - name: PostgreSQL | Turning off postgresql autostart from config "start.conf" (will be managed by patroni)
      copy:
        dest: "{{ postgresql_conf_dir }}/start.conf"
        content: "manual"
        owner: postgres
        group: postgres
        mode: 0644

    - name: PostgreSQL | Disable "postgresql@{{ postgresql_version }}-{{ postgresql_cluster_name }}" service
      systemd:
        name: "postgresql@{{ postgresql_version }}-{{ postgresql_cluster_name }}"
        enabled: false
        daemon_reload: true
  tags: ['patroni']

- name: Patroni | Add PATRONICTL_CONFIG_FILE environment variable into /etc/environment
  ansible.builtin.lineinfile:
    dest: "/etc/environment"
    state: present
    regexp: "^PATRONICTL_CONFIG_FILE"
    line: "PATRONICTL_CONFIG_FILE=/etc/patroni/patroni.yml"
    owner: root
    group: root
    mode: '0644'
  ignore_errors: true
  tags: ['patroni']
